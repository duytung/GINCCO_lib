
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GINCCO_lib.import_daily &#8212; GINCCO_lib 0.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for GINCCO_lib.import_daily</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">netCDF4</span> <span class="kn">import</span> <span class="n">Dataset</span> 

<span class="c1">#############################</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">This module usse to import a single file.</span>

<span class="sd">List of functions: </span>
<span class="sd">* import_section: import vertical section along a line of longitude or latitude (output shape: [x,z])</span>


<span class="sd">Features: </span>
<span class="sd">* Automatically load the correct grid indice (_u, _v, _w, ...)</span>
<span class="sd">* For multiple file, it will check if all the file is available or not, before really load the file to avoid crash in the middle. </span>
<span class="sd">* You can choose to stop the script if any file is missing, or fill the data on that date with nan value</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="c1">#############################</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<div class="viewcode-block" id="section_extract"><a class="viewcode-back" href="../../GINCCO_lib.import_daily.html#GINCCO_lib.import_daily.section_extract">[docs]</a><span class="k">def</span> <span class="nf">section_extract</span><span class="p">(</span><span class="n">lat_array</span><span class="p">,</span> <span class="n">lon_array</span><span class="p">,</span> <span class="n">depth_array</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;idw&quot;</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a vertical section along given (lat, lon) points on a curvilinear grid,</span>
<span class="sd">    and return both the interpolated depth_array section and a callable to apply the</span>
<span class="sd">    same section to any 3-D scalar field on the same grid.</span>

<span class="sd">    Notes:</span>
<span class="sd">    Currently, we only support scalar fields (e.g., temperature, salinity), not vector fields.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">    The data will be imported horizontally, layer by layer, and then all layers will be concatenated to form a section.</span>
<span class="sd">    First, the section will be divided into small parts. For example: lat = 10, lon = [10, 10.1, 10.2, â€¦, 11].</span>
<span class="sd">    In this example, we will have about 10 points.</span>
<span class="sd">    For each point, we find the 4 surrounding grid corners and construct a distance-weighted function.</span>
<span class="sd">    Using this weighted function, we interpolate the value at that point.</span>
<span class="sd">    Repeat this process for all points in layer 1.</span>
<span class="sd">    Repeat for all layers.</span>
<span class="sd">    Since the locations of the points do not change across layers, the weighted function only needs to be calculated once.</span>
<span class="sd">    For each point, we must also apply the same procedure to interpolate the depth_array (not just the data).</span>
<span class="sd">    Because the depth_array varies across points and layers, we interpolate the depth_array grid to obtain the depth_array at each point along the section.</span>
<span class="sd">    Finally, we obtain both the data section and the depth_array section, which can then be plotted as standard 2D data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lat_array : (ny, nx) array_like</span>
<span class="sd">        Grid node latitudes.</span>
<span class="sd">    lon_array : (ny, nx) array_like</span>
<span class="sd">        Grid node longitudes.</span>
<span class="sd">    depth_array : (nz, ny, nx) array_like</span>
<span class="sd">        depth_array values for each model layer on the grid.</span>
<span class="sd">    lat : (M,) array_like</span>
<span class="sd">        Latitudes of section points in order along the section.</span>
<span class="sd">    lon : (M,) array_like</span>
<span class="sd">        Longitudes of section points in order along the section.</span>

<span class="sd">    method : {&quot;idw&quot;, &quot;bilinear&quot;}, optional</span>
<span class="sd">        Interpolation method for the horizontal step:</span>
<span class="sd">          - &quot;idw&quot;: inverse-distance weighting using the 4 surrounding corners.</span>
<span class="sd">          - &quot;bilinear&quot;: true bilinear interpolation inside the local cell.</span>
<span class="sd">        Default is &quot;idw&quot;.</span>
<span class="sd">    power : float, optional</span>
<span class="sd">        Power for IDW distances. Ignored for &quot;bilinear&quot;. Default 2.</span>
<span class="sd">    max_iter : int, optional</span>
<span class="sd">        Maximum Newton iterations for solving bilinear coordinates (s, t).</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Convergence tolerance on position residual for bilinear solve.</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        Small number to avoid division by zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    depth_array_section : (nz, M) ndarray</span>
<span class="sd">        Interpolated depth_array along the section.</span>
<span class="sd">    apply_to_data : callable</span>
<span class="sd">        Function `apply_to_data(data3d)` that returns a data section with shape</span>
<span class="sd">        (nz, M) for any scalar field `data3d` of shape (nz, ny, nx).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Precomputes the surrounding cell and interpolation weights once.</span>
<span class="sd">    - For &quot;bilinear&quot;, it solves for local cell coordinates (s, t) so that</span>
<span class="sd">      P(s, t) matches the query point inside that cell. Falls back to IDW if</span>
<span class="sd">      the solve fails for a point.</span>
<span class="sd">    - depth_array is interpolated with the same precomputed weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># -----------------------------</span>
    <span class="c1"># 0) Basic checks and shaping</span>
    <span class="c1"># -----------------------------</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">lat_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lat_array</span><span class="p">)</span>
    <span class="n">lon_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lon_array</span><span class="p">)</span>
    <span class="n">depth_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">depth_array</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lat_g</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">lon_g</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lat_array and lon_array must have the same shape.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">depth_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">depth_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">lat_g</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;depth_array must have shape (nz, ny, nx) matching the grid.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lat</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">lon</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lat and lon must have the same length.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;idw&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be &#39;idw&#39; or &#39;bilinear&#39;.&quot;</span><span class="p">)</span>

    <span class="n">nz</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">depth_array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># -----------------------------------------</span>
    <span class="c1"># 1) Utilities to locate the surrounding cell</span>
    <span class="c1"># -----------------------------------------</span>

    <span class="c1"># Flatten once for a simple nearest-node search</span>
    <span class="n">lat_flat</span> <span class="o">=</span> <span class="n">lat_g</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lon_flat</span> <span class="o">=</span> <span class="n">lon_g</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nearest_node_indices</span><span class="p">(</span><span class="n">lat_p</span><span class="p">,</span> <span class="n">lon_p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return (iy, ix) of the nearest grid node by Euclidean distance in degree space.&quot;&quot;&quot;</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat_flat</span> <span class="o">-</span> <span class="n">lat_p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">lon_flat</span> <span class="o">-</span> <span class="n">lon_p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>
        <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span>


    <span class="c1"># -----------------------------------------</span>
    <span class="c1"># 2) Prepare storage for geometry per point</span>
    <span class="c1"># -----------------------------------------</span>
    <span class="c1"># Corner order is:</span>
    <span class="c1">#   c00: (iy,   ix  )  top-left</span>
    <span class="c1">#   c10: (iy,   ix+1)  top-right</span>
    <span class="c1">#   c01: (iy+1, ix  )  bottom-left</span>
    <span class="c1">#   c11: (iy+1, ix+1)  bottom-right</span>
    <span class="n">corner_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># For IDW we store per-point weights for the 4 corners</span>
    <span class="n">idw_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># For bilinear we store (s, t) inside the local cell</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># Mark which points ended up using IDW even if method=&quot;bilinear&quot;</span>
    <span class="n">fallback_idw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># -----------------------------------------</span>
    <span class="c1"># 3) Build per-point local geometry</span>
    <span class="c1">#    a) pick a cell around the nearest node</span>
    <span class="c1">#    b) compute either IDW weights or solve bilinear (s, t)</span>
    <span class="c1"># -----------------------------------------</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="c1"># 3a) Find a valid cell around the query point</span>
        <span class="c1"># note the problem about the cell story here. </span>
        <span class="n">iy</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">nearest_node_indices</span><span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">lon</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>



        <span class="c1"># Suppose nearest node is (iy0, ix0)</span>
        <span class="k">if</span> <span class="n">lon</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lon_g</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]:</span>
            <span class="c1">#Point at the right of nearest point</span>
            <span class="n">ix0</span> <span class="o">=</span> <span class="n">ix</span>               <span class="c1"># use [ix0, ix0+1]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Point at the left of nearest point</span>
            <span class="n">ix0</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>           <span class="c1"># use [ix0-1, ix0]</span>

        <span class="k">if</span> <span class="n">lat</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lat_g</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]:</span>
            <span class="c1">#Point higher than the nearest point</span>
            <span class="n">iy0</span> <span class="o">=</span> <span class="n">iy</span>   <span class="c1"># use [iy0, iy0+1]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Point lower than the nearest point</span>
            <span class="n">iy0</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>           <span class="c1"># use [iy0-1, iy0]</span>

        <span class="c1"># Clamp inside valid range</span>
        <span class="n">iy0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">iy0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ix0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">ix0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Corners of the enclosing cell</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span>    <span class="p">],</span>  <span class="c1"># c00</span>
            <span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># c10</span>
            <span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span>    <span class="p">],</span>  <span class="c1"># c01</span>
            <span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>   <span class="c1"># c11</span>
        <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">corner_ids</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">corners</span>

        <span class="c1"># Extract corner coordinates</span>
        <span class="n">y00</span><span class="p">,</span> <span class="n">x00</span> <span class="o">=</span> <span class="n">lat_g</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">],</span>     <span class="n">lon_g</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span><span class="p">]</span>
        <span class="n">y10</span><span class="p">,</span> <span class="n">x10</span> <span class="o">=</span> <span class="n">lat_g</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lon_g</span><span class="p">[</span><span class="n">iy0</span><span class="p">,</span>     <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">y01</span><span class="p">,</span> <span class="n">x01</span> <span class="o">=</span> <span class="n">lat_g</span><span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">],</span>     <span class="n">lon_g</span><span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span><span class="p">]</span>
        <span class="n">y11</span><span class="p">,</span> <span class="n">x11</span> <span class="o">=</span> <span class="n">lat_g</span><span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lon_g</span><span class="p">[</span><span class="n">iy0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Distances to corners (used for IDW and for exact-hit shortcut)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y00</span><span class="p">,</span> <span class="n">y10</span><span class="p">,</span> <span class="n">y01</span><span class="p">,</span> <span class="n">y11</span><span class="p">])</span> <span class="o">-</span> <span class="n">lat</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x00</span><span class="p">,</span> <span class="n">x10</span><span class="p">,</span> <span class="n">x01</span><span class="p">,</span> <span class="n">x11</span><span class="p">])</span> <span class="o">-</span> <span class="n">lon</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>

        <span class="c1"># If the query hits a node exactly, make it a pure pick</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">idw_w</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
            <span class="n">st</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># not used</span>
            <span class="n">fallback_idw</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bilinear&quot;</span> <span class="k">else</span> <span class="kc">False</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;idw&quot;</span><span class="p">:</span>
            <span class="c1"># 3b-IDW) Inverse-distance weights on the 4 corners</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dist</span><span class="o">**</span><span class="n">power</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">/=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">idw_w</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 3b-Bilinear) Solve for (s, t) in the bilinear mapping</span>
            <span class="c1"># Position function:</span>
            <span class="c1">#   X(s,t) = x00*(1-s)*(1-t) + x10*s*(1-t) + x01*(1-s)*t + x11*s*t</span>
            <span class="c1">#   Y(s,t) = y00*(1-s)*(1-t) + y10*s*(1-t) + y01*(1-s)*t + y11*s*t</span>
            <span class="c1"># Solve F(s,t) = [X(s,t)-xq, Y(s,t)-yq] = 0 by Newton iterations</span>
            <span class="n">xq</span><span class="p">,</span> <span class="n">yq</span> <span class="o">=</span> <span class="n">lon</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
                <span class="c1"># Evaluate mapping</span>
                <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">x00</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">x10</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">x01</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">x11</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y00</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">y10</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">y01</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">y11</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
                <span class="n">rx</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">xq</span>
                <span class="n">ry</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">-</span> <span class="n">yq</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

                <span class="c1"># Jacobian entries</span>
                <span class="n">dXds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">x00</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">x10</span> <span class="o">-</span> <span class="n">t</span><span class="o">*</span><span class="n">x01</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">x11</span><span class="p">)</span>
                <span class="n">dXdt</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">x00</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="n">x10</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">x01</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">x11</span><span class="p">)</span>
                <span class="n">dYds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">y00</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">y10</span> <span class="o">-</span> <span class="n">t</span><span class="o">*</span><span class="n">y01</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">y11</span><span class="p">)</span>
                <span class="n">dYdt</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">y00</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="n">y10</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">y01</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">y11</span><span class="p">)</span>

                <span class="c1"># Solve 2x2 linear system J * [ds, dt]^T = -[rx, ry]^T</span>
                <span class="n">det</span> <span class="o">=</span> <span class="n">dXds</span><span class="o">*</span><span class="n">dYdt</span> <span class="o">-</span> <span class="n">dXdt</span><span class="o">*</span><span class="n">dYds</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">rx</span><span class="o">*</span><span class="n">dYdt</span> <span class="o">+</span> <span class="n">dXdt</span><span class="o">*</span><span class="n">ry</span><span class="p">)</span> <span class="o">/</span> <span class="n">det</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">dXds</span><span class="o">*</span><span class="n">ry</span> <span class="o">+</span> <span class="n">rx</span><span class="o">*</span><span class="n">dYds</span><span class="p">)</span> <span class="o">/</span> <span class="n">det</span>

                <span class="c1"># Update guess</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">ds</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

                <span class="c1"># Optional clamping helps keep iterations stable</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">))</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ok</span> <span class="ow">and</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">-</span> <span class="mf">1e-6</span> <span class="o">&lt;=</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">-</span> <span class="mf">1e-6</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">):</span>
                <span class="c1"># Store solved (s, t)</span>
                <span class="n">st</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
                <span class="n">st</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fall back to IDW if the solve failed</span>
                <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dist</span><span class="o">**</span><span class="n">power</span><span class="p">)</span>
                <span class="n">w</span> <span class="o">/=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">idw_w</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
                <span class="n">fallback_idw</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># -----------------------------------------</span>
    <span class="c1"># 4) Helper to combine corner values into a single interpolated value</span>
    <span class="c1"># -----------------------------------------</span>
    <span class="k">def</span> <span class="nf">combine_layer</span><span class="p">(</span><span class="n">values4</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine 4 corner values for point m into one value according to method.</span>

<span class="sd">        values4 order: [c00, c10, c01, c11]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bilinear&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fallback_idw</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="c1"># Bilinear weights</span>
            <span class="n">w00</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">w10</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">w01</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span>
            <span class="n">w11</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">t</span>
            <span class="k">return</span> <span class="n">w00</span><span class="o">*</span><span class="n">values4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w10</span><span class="o">*</span><span class="n">values4</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w01</span><span class="o">*</span><span class="n">values4</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">w11</span><span class="o">*</span><span class="n">values4</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># IDW path</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">idw_w</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">values4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">values4</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">values4</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">values4</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># -----------------------------------------</span>
    <span class="c1"># 5) Interpolate the depth_array section using precomputed geometry</span>
    <span class="c1"># -----------------------------------------</span>
    <span class="n">depth_section</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nz</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">depth_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
        <span class="c1"># Gather corner values for all points</span>
        <span class="n">c00</span> <span class="o">=</span> <span class="n">depth_array</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">c10</span> <span class="o">=</span> <span class="n">depth_array</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">c01</span> <span class="o">=</span> <span class="n">depth_array</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">c11</span> <span class="o">=</span> <span class="n">depth_array</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># Combine per point</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">depth_section</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">combine_layer</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c00</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">c10</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">c01</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">c11</span><span class="p">[</span><span class="n">m</span><span class="p">]]),</span> <span class="n">m</span>
            <span class="p">)</span>

    <span class="c1"># -----------------------------------------</span>
    <span class="c1"># 6) Return a callable for any scalar 3-D field</span>
    <span class="c1"># -----------------------------------------</span>
    <span class="k">def</span> <span class="nf">apply_to_data</span><span class="p">(</span><span class="n">data3d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate a scalar field on the same grid onto the pre-defined section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data3d : (nz, ny, nx) array_like</span>
<span class="sd">            Scalar field (e.g., temperature, salinity).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_section : (nz, M) ndarray</span>
<span class="sd">            Interpolated values along the section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data3d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nz</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;data3d must have shape </span><span class="si">{</span><span class="p">(</span><span class="n">nz</span><span class="p">,</span><span class="w"> </span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">nx</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nz</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
            <span class="n">c00</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">c10</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">c01</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">c11</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">corner_ids</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">combine_layer</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c00</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">c10</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">c01</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">c11</span><span class="p">[</span><span class="n">m</span><span class="p">]]),</span> <span class="n">m</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">return</span> <span class="n">depth_section</span><span class="p">,</span> <span class="n">apply_to_data</span></div>



<span class="c1"># -----------------------------------------</span>

<div class="viewcode-block" id="data_interp"><a class="viewcode-back" href="../../GINCCO_lib.import_daily.html#GINCCO_lib.import_daily.data_interp">[docs]</a><span class="k">def</span> <span class="nf">data_interp</span><span class="p">(</span><span class="n">depth_sec</span><span class="p">,</span> <span class="n">data_sec</span><span class="p">,</span> <span class="n">depth_interval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate irregular-depth section data (nz, M) onto one shared regular depth grid.</span>

<span class="sd">    Assumptions</span>
<span class="sd">    ----------</span>
<span class="sd">    - Each column in depth_sec is ordered (shallow to deep).</span>
<span class="sd">    - No extrapolation: values outside a column&#39;s native range are NaN.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    depth_sec : ndarray, shape (nz, M)</span>
<span class="sd">        Irregular depths for each column.</span>
<span class="sd">    data_sec : ndarray, shape (nz, M)</span>
<span class="sd">        Data at the given depths.</span>
<span class="sd">    depth_interval : float, optional</span>
<span class="sd">        Spacing for the target depth grid.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_depth : ndarray, shape (K, M)</span>
<span class="sd">        Shared regular depth grid replicated across columns.</span>
<span class="sd">    data_out : ndarray, shape (K, M)</span>
<span class="sd">        Interpolated data on new_depth.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">depth_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">depth_sec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">data_sec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data_sec</span><span class="p">,</span>  <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">depth_sec</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data_sec</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;depth_sec and data_sec must have the same shape (nz, M).&quot;</span><span class="p">)</span>

    <span class="c1"># Global min and max across the entire array</span>
    <span class="n">global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">depth_sec</span><span class="p">)</span>
    <span class="n">global_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">depth_sec</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">global_min</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">global_max</span><span class="p">)</span> <span class="ow">or</span> <span class="n">global_max</span> <span class="o">&lt;=</span> <span class="n">global_min</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid global depth bounds for target grid.&quot;</span><span class="p">)</span>

    <span class="c1"># Build shared target grid</span>
    <span class="n">z1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">global_min</span><span class="p">,</span> <span class="n">global_max</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">depth_interval</span><span class="p">))</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">z1d</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">depth_sec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Interpolate each column without extrapolation</span>
    <span class="n">data_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">depth_sec</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">data_sec</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">z1d</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">col</span><span class="p">[(</span><span class="n">z1d</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">z1d</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">data_out</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>

    <span class="c1"># Depth grid replicated to (K, M)</span>
    <span class="n">new_depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">z1d</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_depth</span><span class="p">,</span> <span class="n">data_out</span></div>




<div class="viewcode-block" id="import_section"><a class="viewcode-back" href="../../GINCCO_lib.import_daily.html#GINCCO_lib.import_daily.import_section">[docs]</a><span class="k">def</span> <span class="nf">import_section</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">,</span> <span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">depth_interval</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Import a vertical section from a file. Support all kind of section: along lat, along lon, and diagonal line. </span>
<span class="sd">    This is the control for the whole function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path to file. This path should contain the grid.nc as well</span>
<span class="sd">    file_name : str</span>
<span class="sd">        Name of the file</span>
<span class="sd">    var : str</span>
<span class="sd">        Name of the variable</span>
<span class="sd">    lon_min, lon_max, lat_min, lat_max : float    </span>
<span class="sd">        limit of the line: if lon_min = lon_max, it will understand it as a line along the longitude, and vice versa. </span>
<span class="sd">    M: int</span>
<span class="sd">        the number of point in the section following its direction from A to B</span>
<span class="sd">    depth_interval: float</span>
<span class="sd">        the interval of Z. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_depth : ndarray, shape (K, M)</span>
<span class="sd">        Shared regular depth grid replicated across columns.</span>
<span class="sd">    data_out : ndarray, shape (K, M)</span>
<span class="sd">        Interpolated data on new_depth.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Open the grid file to determine depth dimensions</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/grid.nc&#39;</span><span class="p">))</span>
    <span class="n">fgrid</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">lat_t</span> <span class="o">=</span> <span class="n">fgrid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;latitude_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])][:]</span>
        <span class="n">lon_t</span> <span class="o">=</span> <span class="n">fgrid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;longitude_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])][:]</span>
        <span class="n">depth_t</span> <span class="o">=</span> <span class="n">fgrid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;depth_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])][:]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find a grid suffix for </span><span class="si">%s</span><span class="s1">. Using _t as default.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="n">lat_t</span> <span class="o">=</span> <span class="n">fgrid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;latitude_t&#39;</span><span class="p">][:]</span>
        <span class="n">lon_t</span> <span class="o">=</span> <span class="n">fgrid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;longitude_t&#39;</span><span class="p">][:]</span>
        <span class="n">depth_t</span> <span class="o">=</span> <span class="n">fgrid</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;depth_t&#39;</span><span class="p">][:]</span>
    
    <span class="n">nc_file</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">nc_file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">][:])</span>


    <span class="c1"># Setup the section</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lon_min</span> <span class="o">==</span> <span class="n">lon_max</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lat_min</span> <span class="o">==</span> <span class="n">lat_max</span><span class="p">:</span>  
            <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;lon_min = lon_max and lat_min = lat_max. Not a section. Exiting...&#39;</span> <span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lon_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">)</span>
            <span class="n">lat_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">lat_min</span> <span class="o">==</span> <span class="n">lat_max</span><span class="p">:</span>
            <span class="n">lat_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">)</span>
            <span class="n">lon_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lat_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>      <span class="c1"># lat section</span>
        <span class="n">lon_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>      <span class="c1"># lon_section</span>

    <span class="n">depth_sec</span><span class="p">,</span> <span class="n">apply_interp</span> <span class="o">=</span> <span class="n">section_extract</span><span class="p">(</span><span class="n">lat_t</span><span class="p">,</span> <span class="n">lon_t</span><span class="p">,</span> <span class="n">depth_t</span><span class="p">,</span> <span class="n">lat_sec</span><span class="p">,</span> <span class="n">lon_sec</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bilinear&quot;</span><span class="p">)</span>

    <span class="c1">#interpolate data</span>
    <span class="n">data_interpolation</span> <span class="o">=</span> <span class="n">apply_interp</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># shape: (nz, M)</span>

    <span class="c1">#interpolate depth and data into 1m for better representation</span>
    <span class="n">depth_out</span><span class="p">,</span> <span class="n">data_out</span> <span class="o">=</span> <span class="n">data_interp</span><span class="p">(</span><span class="n">depth_sec</span><span class="p">,</span> <span class="n">data_interpolation</span><span class="p">,</span> <span class="n">depth_interval</span><span class="o">=</span><span class="n">depth_interval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">depth_out</span><span class="p">,</span> <span class="n">data_out</span></div>











</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">GINCCO_lib</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">GINCCO_lib package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test_autodoc.html">Test autodoc</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, Tung Nguyen-Duy.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>